\chapter*{Установка}

\section*{VS Code и Calva}

Установить VS Code под свою платоформу можно по ссылке: \url{https://code.visualstudio.com/Download}

Для тех, кто не имеет опыта использования IDE или желает научиться использовать VS Code, рекомендуются к прочтению следующие статьи:
\begin{enumerate}[label=\arabic*)]
	\item \url{https://habr.com/ru/post/490754/} --- статья на русском языке
	\item \url{https://code.visualstudio.com/docs/introvideos/basics} --- статья на английском языке
\end{enumerate}

Далее необходимо установить Calva --- расширение для VS Code, поддерживающее ClojureScript и помогающее разрабатывать ПО на Clojure. 
Для этого в левом меню VS Code необходимо перейти в раздел ''Расширения'' (см. скриншот \ref{img:vscode-extension}), сделать поиск ''Calva'' и установить найденное расширение (см. скриншот \ref{img:vscode-calva}).

\imgScale{0.3}{vscode-extension}{Раздел ''Расширения'' VS Code}

\imgScale{0.3}{vscode-calva}{Расширение Calva}

\section*{Clojure}
Для того, чтобы установить Clojure, воспользуемся инструкциями с официального сайта: \url{https://clojure.org/guides/install_clojure}.

В приведённой статье (на английском языке) присутствую инструкции по установке Clojure на ОС MacOS, Linux-подобные ОС (Ubuntu, Debian), а также Windows. 
В данном мануале будет рассмотрена установка Clojure на Linux-подобные ОС посредством установщика пакетов brew.

Для установки необходимо открыть терминал и выполнить в нём следующие команды:

\begin{center}
	\captionsetup{justification=raggedright,singlelinecheck=off}
	\begin{lstlisting}[label=lst:brew,caption=Установка brew]
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
(echo; echo 'eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"') >> /home/<YOURUSERNAME>/.profile
eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
sudo apt-get install build-essentials
	\end{lstlisting}
\end{center}

После установки brew необходимо установить и сам Clojure:

\begin{center}
	\captionsetup{justification=raggedright,singlelinecheck=off}
	\begin{lstlisting}[label=lst:brewclojure,caption=Установка Clojure]
brew install clojure/tools/clojure
	\end{lstlisting}
\end{center}

\section*{LISP}

Поскольку Clojure является диалектом LISP, стоит также установить и базовый интерпретатор LISP,  например, Common Lisp.
Для ОС семейства Linux это можно сделать следующей командой:

\begin{center}
	\captionsetup{justification=raggedright,singlelinecheck=off}
	\begin{lstlisting}[label=lst:brewclojure,caption=Установка Common Lisp]
sudo apt-get install sbcl
	\end{lstlisting}
\end{center}


\chapter*{Начало работы и примеры}

\section*{Hello World, Clojure}

Откроем VS Code и нажмём Ctrl + Shift + P (данное сочетание клавиш откроет паллет управления в VS Code) и введём следующий текст: Calva: Fire up the Getting Started REPL
Среди появившихся результатов выберем единственный:

\imgScale{0.25}{vscode-start-calva}{Запуск Calva}

После запуска Calva мы увидим примерно следующее:

\imgScale{0.25}{vscode-calva-started}{После запуска Calva}

Очистим содержимое левого файла и напишем в него ''Hello, World!'':

\imgScale{0.3}{vscode-hello-world-written}{Напишем ''Hello, World!''}

Нажмём Alt + Enter и увидим результат:

\imgScale{0.6}{vscode-hello-world}{Hello, World!}


\section*{Hello World, ClojureScript}



%\section{Матрица}
%
%\textbf{Матрицой}~\cite{matrix} называют таблицу чисел $a_{ik}$ вида
%\begin{equation}
%	\begin{pmatrix}
%		a_{11} & a_{12} & \ldots & a_{1n}\\
%		a_{21} & a_{22} & \ldots & a_{2n}\\
%		\vdots & \vdots & \ddots & \vdots\\
%		a_{m1} & a_{m2} & \ldots & a_{mn}
%	\end{pmatrix},
%\end{equation}
%
%состоящую из $m$ строк и $n$ столбцов. Числа $a_{ik}$ называются её \textit{элементами}.
%
%Пусть $A$ -- матрица, тогда $A_{i,j}$ -- элемент этой матрицы, который находится на \textit{i-ой} строке и \textit{j-ом} столбце.
%
%Можно выделить следующие операции над матрицами:
%\begin{enumerate}[label=\arabic*)]
%    \item сложение матриц одинакового размера;
%    \item вычитание матриц одинакового размера;
%    \item умножение матриц в случае, если количество столбцов первой матрицы равно количеству строк второй матрицы. В итоговой матрице количество строк будет, как у первой матрицы, а столбцов -- как у второй. \newline
%\end{enumerate}
%
%\textit{Замечание:} операция умножения матриц не коммутативна -- если \textit{A} и \textit{B} -- квадратные матрицы, а \textit{C} -- результат их перемножения, то произведение \textit{AB} и \textit{BA} дадут разный результат \textit{C}.
%\clearpage
%
%\section{Стандартный алгоритм}
%
%Пусть даны две матрицы
%
%\begin{equation}
%	A_{lm} = \begin{pmatrix}
%		a_{11} & a_{12} & \ldots & a_{1m}\\
%		a_{21} & a_{22} & \ldots & a_{2m}\\
%		\vdots & \vdots & \ddots & \vdots\\
%		a_{l1} & a_{l2} & \ldots & a_{lm}
%	\end{pmatrix},
%	\quad
%	B_{mn} = \begin{pmatrix}
%		b_{11} & b_{12} & \ldots & b_{1n}\\
%		b_{21} & b_{22} & \ldots & b_{2n}\\
%		\vdots & \vdots & \ddots & \vdots\\
%		b_{m1} & b_{m2} & \ldots & b_{mn}
%	\end{pmatrix},
%\end{equation}
%
%тогда матрица $C$
%\begin{equation}
%	C_{ln} = \begin{pmatrix}
%		c_{11} & c_{12} & \ldots & c_{1n}\\
%		c_{21} & c_{22} & \ldots & c_{2n}\\
%		\vdots & \vdots & \ddots & \vdots\\
%		c_{l1} & c_{l2} & \ldots & c_{ln}
%	\end{pmatrix},
%\end{equation}
%
%где
%\begin{equation}
%	\label{eq:M}
%	c_{ij} =
%	\sum_{r=1}^{m} a_{ir}b_{rj} \quad (i=\overline{1,l}; j=\overline{1,n})
%\end{equation}
%
%будет называться произведением матриц $A$ и $B$ \cite{matrix}.
%
%Стандартный алгоритм~\cite{vinograd-matrix} реализует данную формулу.
%
%
%\section{Алгоритм Винограда}
%
%\textbf{Алгоритм Винограда}~\cite{vinograd-matrix} -- алгоритм умножения квадратных матриц. Начальная версия имела асимптотическую сложность алгоритма примерно $O(n^{2,3755})$, где $n$ -- размер стороны матрицы, но после доработки он стал обладать лучшей асимптотикой среди всех алгоритмов умножения матриц.
%
%Рассмотрим два вектора $U = (u_1, u_2, u_3, u_4)$ и $W = (w_1, w_2, w_3, w_4)$.
%Их скалярное произведение равно: $U \cdot W = u_1w_1 + u_2w_2 + u_3w_3 + u_4w_4$, что эквивалентно (\ref{for:new}).
%\begin{equation}
%	\label{for:new}
%	V \cdot W = (u_1 + w_2)(u_2 + w_1) + (u_3 + w_4)(u_4 + w_3) - u_1u_2 - u_3u_4 - w_1w_2 - w_3w_4.
%\end{equation}
%
%За счёт предварительной обработки данных можно получить прирост производительности: несмотря на то, что  полученное выражение требует большего количества операций, чем стандартное умножение матриц, выражение в правой части равенства можно вычислить заранее и запомнить для каждой строки первой матрицы и каждого столбца второй матрицы. 
%Это позволит выполнить лишь два умножения и пять сложений, при учёте, что потом будет сложено только с двумя предварительно посчитанными суммами соседних элементов текущих строк и столбцов. 
%Операция сложения выполняется быстрее, поэтому на практике алгоритм должен работать быстрее обычного алгоритма перемножения матриц.
%
%Стоит упомянуть, что при нечётном значении размера матрицы нужно дополнительно добавить произведения крайних элементов соответствующих строк и столбцов.
%
%\section{Оптимизация алгоритма Винограда}
%
%При программной реализации рассмотренного выше алгоритма Винограда можно сделать следующие оптимизации:
%\begin{enumerate}[label=\arabic*)]
%	\item значение $\frac{N}{2}$, используемое как ограничения цикла подсчёта предварительных данных, можно кэшировать;
%	\item операцию умножения на 2 программно эффективнее реализовывать как побитовый сдвиг влево на 1;
%	\item операции сложения и вычитания с присваиванием следует реализовывать при помощи соответствующего оператора $+=$ или $-=$ (при наличии данных операторов в выбранном языке программирования).
% \end{enumerate}
%
%
%\section*{Вывод}
%
%В данном разделе были рассмотрены алгоритмы умножения матриц -- стандартного и Винограда, который имеет большую эффективность за счёт предварительных вычислений. 
%Также были рассмотрены оптимизации, которые можно учесть при программной реализации алгоритма Винограда.
%
%Алгоритмы будут получать на вход две матрицы, причём количество столбцов одной матрицы должно совпадать с количеством строк второй матрицы. 
%При вводе пустой матрицы будет выведено сообщение об ошибке. 
%Требуется реализовать программное обеспечение, которое даёт возможность выбрать один из алгоритмов или все сразу, ввести две матрицы и вывести результат их перемножения.
%Также необходимо провести замеры времени работы реализаций алгоритмов для чётных и нечётных размеров матриц и сравнить результаты, используя графическое представление.
