\chapter*{Установка}

\section*{VS Code и Calva}

Установить VS Code под свою платоформу можно по ссылке: \url{https://code.visualstudio.com/Download}

Для тех, кто не имеет опыта использования IDE или желает научиться использовать VS Code, рекомендуются к прочтению следующие статьи:
\begin{enumerate}[label=\arabic*)]
	\item \url{https://habr.com/ru/post/490754/} --- статья на русском языке
	\item \url{https://code.visualstudio.com/docs/introvideos/basics} --- статья на английском языке
\end{enumerate}

Далее необходимо установить Calva --- расширение для VS Code, поддерживающее ClojureScript и помогающее разрабатывать ПО на Clojure. 
Для этого в левом меню VS Code необходимо перейти в раздел ''Расширения'' (см. скриншот \ref{img:vscode-extension}), сделать поиск ''Calva'' и установить найденное расширение (см. скриншот \ref{img:vscode-calva}).

\imgScale{0.3}{vscode-extension}{Раздел ''Расширения'' VS Code}

\imgScale{0.3}{vscode-calva}{Расширение Calva}

\section*{Clojure}
Для того, чтобы установить Clojure, воспользуемся инструкциями с официального сайта: \url{https://clojure.org/guides/install_clojure}.

В приведённой статье (на английском языке) присутствую инструкции по установке Clojure на ОС MacOS, Linux-подобные ОС (Ubuntu, Debian), а также Windows. 
В данном мануале будет рассмотрена установка Clojure на Linux-подобные ОС посредством установщика пакетов brew.

Для установки необходимо открыть терминал и выполнить в нём следующие команды:

\begin{center}
	\captionsetup{justification=raggedright,singlelinecheck=off}
	\begin{lstlisting}[label=lst:brew,caption=Установка brew]
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
(echo; echo 'eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"') >> /home/<YOURUSERNAME>/.profile
eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
sudo apt-get install build-essentials
	\end{lstlisting}
\end{center}

После установки brew необходимо установить и сам Clojure:

\begin{center}
	\captionsetup{justification=raggedright,singlelinecheck=off}
	\begin{lstlisting}[label=lst:brewclojure,caption=Установка Clojure]
brew install clojure/tools/clojure
	\end{lstlisting}
\end{center}

\section*{LISP}

Поскольку Clojure является диалектом LISP, стоит также установить и базовый интерпретатор LISP,  например, Common Lisp.
Для ОС семейства Linux это можно сделать следующей командой:

\begin{center}
	\captionsetup{justification=raggedright,singlelinecheck=off}
	\begin{lstlisting}[label=lst:brewclojure,caption=Установка Common Lisp]
sudo apt-get install sbcl
	\end{lstlisting}
\end{center}


\chapter*{Начало работы и примеры}

\section*{Hello World, Clojure}

Откроем VS Code и нажмём Ctrl + Shift + P (данное сочетание клавиш откроет паллет управления в VS Code) и введём следующий текст: Calva: Fire up the Getting Started REPL
Среди появившихся результатов выберем единственный:

\imgScale{0.25}{vscode-start-calva}{Запуск Calva}

После запуска Calva мы увидим примерно следующее:

\imgScale{0.25}{vscode-calva-started}{После запуска Calva}

Очистим содержимое левого файла и напишем в него ''Hello, World!'':

\imgScale{0.3}{vscode-hello-world-written}{Напишем ''Hello, World!''}

Нажмём Alt + Enter и увидим результат:

\imgScale{0.6}{vscode-hello-world}{Hello, World!}


\section*{Hello World, ClojureScript}

Чтобы запустить Hello World с использованием ClojureScript, мы будем выполнять действия по следующему гайду:

\url{https://clojurescript.org/guides/quick-start}

Для этого создадим папку hello-world и настроим её содержимое следующим образом: 

\clearpage

\begin{center}
	\captionsetup{justification=raggedright,singlelinecheck=off}
	\begin{lstlisting}[label=lst:clojurehelloworld,caption=ClojureScirpt, Hello World]
hello-world        # Our project folder
	src             # The CLJS source code for our project
		hello_world  # Our hello_world namespace folder
			core.cljs # Our main file
	cljs.jar        # (Windows only) The standalone Jar you downloaded earlier
	deps.edn        # (macOS/Linux only) A file for listing our dependencies
	\end{lstlisting}
\end{center}

Содержимое deps.edn:

\begin{center}
	\captionsetup{justification=raggedright,singlelinecheck=off}
	\begin{lstlisting}[label=lst:clojurehelloworld-1,caption=Содержимое deps.edn]
{:deps {org.clojure/clojurescript {:mvn/version "1.11.54"}}}
	\end{lstlisting}
\end{center}

Содержимое src/hello\_world/core.cljs:

\begin{center}
	\captionsetup{justification=raggedright,singlelinecheck=off}
	\begin{lstlisting}[label=lst:clojurehelloworld-1,caption=Содержимое src/hello\_world/core.cljs]
(ns hello-world.core)

(println "Hello world!")
	\end{lstlisting}
\end{center}

После чего запустим в терминал следующую команду:

\begin{center}
	\captionsetup{justification=raggedright,singlelinecheck=off}
	\begin{lstlisting}[label=lst:clojurehelloworld-1,caption=Запуск в терминале]
clj -M --main cljs.main --compile hello-world.core --repl
	\end{lstlisting}
\end{center}

В браузере при этом должна открыться следующая страница:

\imgScale{0.5}{browser}{Hello, World!}

После этого в терминале, из которого произходил запуск, должно появиться сообщение Hello World!

Попробуем добавить несколько функций. Для этого изменим содержимое src/hello\_world/core.cljs:

\begin{center}
	\captionsetup{justification=raggedright,singlelinecheck=off}
	\begin{lstlisting}[label=lst:clojurehelloworld-1,caption=Содержимое src/hello\_world/core.cljs]
(ns hello-world.core)

(println "Hello world!")

;; ADDED
(defn average [a b]
	(/ (+ a b) 2.0))
	
(defn plus [a b]
	(+ a b))
	\end{lstlisting}
\end{center}

Перекомпилируем рабочее пространство, выполнив в терминале следующие команды:

\begin{center}
	\captionsetup{justification=raggedright,singlelinecheck=off}
	\begin{lstlisting}[label=lst:clojurehelloworld-2,caption=Обновление страницы проверка новых функций ]
(require '[hello-world.core :as hello] :reload)
(hello/average 20 13)
(hello/plus 1 21)
\end{lstlisting}
\end{center}

В терминале должны отобразиться результаты работы функций - числа 16.5 и 22.

Отдельно отметим, что в папке out можно найти скомпилированный \newline JavaScript код.
Исследовав её содержимое, можно придти к выводу, что полученный  код является ни слишком оптимизированным.
Для того, чтобы получить более оптимизированную версию кода, необходимо запустить ClojureScript компилятор со следующими опциями:

\begin{center}
	\captionsetup{justification=raggedright,singlelinecheck=off}
	\begin{lstlisting}[label=lst:clojurehelloworld-3,caption=Получение оптимизированной сборки]
clj -M -m cljs.main --optimizations advanced -c hello-world.core
	\end{lstlisting}
\end{center}

Оптимизированная сборка (со значением advanced) может быть использована для получения итоговой сборки, которая будет использована не разработчиками, а пользователями.

\section*{Нахождение обратной матрицы, ClojureScript}

Как более сложный пример программы на ClojureScript предлагается рассмотреть функции нахождения для квадратной матрицы обратной матрицы и детерминанта: 

\begin{center}
	\captionsetup{justification=raggedright,singlelinecheck=off}
	\begin{lstlisting}[label=lst:clojurehelloworld-4,caption=Нахождение обратной матрицы]
(ns hello-repl)

(defn matMake
  [rows cols val]
  (with-local-vars [result [], i 0, j 0, tmp []]
	(while (< @i rows)
	  (var-set tmp [])
	  (var-set j 0)
	  (while (< @j cols)
		(var-set tmp (conj @tmp val))
		(var-set j (inc @j)))
	  (var-set result (conj @result @tmp))
	  (var-set i (inc @i)))
	@result))

(defn vecMake
  [n val]
  (with-local-vars [result [], i 0]
	(while (< @i n)
	  (var-set result (conj @result val))
	  (var-set i (inc @i)))
	@result))

(defn matDecompose
  [matrix n lum perm result]
  (with-local-vars [tmp [], toggle 1, i 0, j 0, k 0, mx 0.0, piv 0, xij 0.0, ij 0.0, t 0.0]
	(while (< @i n)
	  (var-set j 0)
	  (var-set tmp [])
	  (while (< @j n)
		(var-set tmp (conj @tmp ((matrix @i) @j)))
		(var-set j (inc @j)))
	  (var-set lum (assoc @lum @i @tmp))
	  (var-set i (inc @i)))

	(var-set i 0)
	(var-set tmp [])
	(while (< @i n)
	  (var-set tmp (conj @tmp @i))
	  (var-set i (inc @i)))
	(var-set perm (vec @tmp))

	(var-set i 0)
	(var-set j 0)
	(while (< @j (- n 1))
	  (var-set mx (abs ((@lum @j) @j)))
	  (var-set piv @j)
	  (var-set i (inc @j))

	  (while (< @i n)
		(var-set ij (abs ((@lum @i) @j)))
		(if (> @ij @mx)
		  (do
			(var-set mx @ij)
			(var-set piv @i)
			true))

		(var-set i (inc @i)))

	  (if-not (= @piv @j)
		(do (var-set t (@lum @piv))
			(var-set lum (assoc @lum @piv (@lum @j)))
			(var-set lum (assoc @lum @j @t))

			(var-set t (@perm @piv))
			(var-set perm (assoc @perm @piv (@perm @j)))
			(var-set perm (assoc @perm @j @t))

			(var-set toggle (* -1 @toggle))
			true))

	  (var-set xij ((@lum @j) @j))
	  (if-not (= @xij 0)
		(do
		  (var-set i (inc @j))

		  (while (< @i n)
			(var-set tmp (@lum @i))
			(var-set ij (/ ((@lum @i) @j) @xij))
			(var-set tmp (assoc @tmp @j @ij))
			(var-set k (inc @j))
			(var-set lum (assoc @lum @i @tmp))

			(while (< @k n)

			  (var-set tmp (assoc @tmp @k (- (@tmp @k) (* ((@lum @j) @k) @ij))))
			  (var-set k (inc @k)))

			(var-set lum (assoc @lum @i @tmp))

			(var-set i (inc @i)))

		  true))
	  (var-set j (inc @j)))


	(var-set result @toggle)))

(defn matDeterminant
  [matrix n]
  (with-local-vars [result 0, lum (matMake n n 0.0), perm (vecMake n 0.0), i 0]
	(matDecompose matrix n lum perm result)
	(while (< @i n)
	  (var-set result (* @result ((@lum @i) @i)))
	  (var-set i (inc @i)))
	@result))

(defn myReduce
  [n lum b x]
  (with-local-vars [i 0, j 0, tmp [], sum 0.0]

	(var-set i 0)
	(var-set tmp [])
	(while (< @i n)
	  (var-set tmp (conj @tmp (@b @i)))
	  (var-set i (inc @i)))
	(var-set x (vec @tmp))

	(var-set i 1)
	(while (< @i n)
	  (var-set sum (@x @i))
	  (var-set j 0)

	  (while (< @j @i)
		(var-set sum (- @sum (* ((@lum @i) @j) (@x @j))))
		(print @sum)
		(print "\n")
		(var-set j (inc @j)))

	  (var-set x (assoc @x @i @sum))

	  (var-set i (inc @i)))
	(var-set x (assoc @x (- n 1) (/ (@x (- n 1)) ((@lum (- n 1)) (- n 1)))))

	(var-set i (- n 2))

	(while (>= @i 0)
	  (var-set sum (@x @i))
	  (var-set j (inc @i))
	  (while (< @j n)
		(var-set sum (- @sum (* ((@lum @i) @j) (@x @j))))
		(print @sum)
		(print "\n")
		(var-set j (inc @j)))
	  (var-set x (assoc @x @i (/ @sum ((@lum @i) @i))))

	  (var-set i (dec @i)))
	@x))

(defn matInverse
  [matrix n]
  (with-local-vars [result (matMake n n 0.0), lum (matMake n n 0.0), perm (vecMake n 0.0), i 0, j 0, tmp [], det 0.0, b (vecMake n 0.0), x (vecMake n 0.0)]

	(while (< @i n)
	  (var-set j 0)
	  (var-set tmp [])
	  (while (< @j n)
		(var-set tmp (conj @tmp ((matrix @i) @j)))
		(var-set j (inc @j)))
	  (var-set result (assoc @result @i @tmp))
	  (var-set i (inc @i)))

	(matDecompose matrix n lum perm det)

	(var-set i 0)
	(while (< @i n)
	  (var-set j 0)
	  (while (< @j n)
		(if (= @i (@perm @j))
		  (var-set b (assoc @b @j 1.0))
		  (var-set b (assoc @b @j 0.0)))
		(var-set j (inc @j)))

	  (myReduce n lum b x)

	  (var-set j 0)
	  (while (< @j n)
		(var-set tmp (@result @j))
		(var-set tmp (assoc @tmp @i (@x @j)))
		(var-set result (assoc @result @j @tmp))
		(var-set j (inc @j)))

	  (var-set i (inc @i)))


	@result))

;; (matDeterminant [[1.0 2.0] [3.0 4.0]] 2)
;; (matDeterminant [[1.0 2.0 3.0] [4.0 5.0 6.0] [7.0 8.0 9.0]] 3)
;; (matInverse [[1.0 2.0] [3.0 4.0]] 2)
;; (matInverse [[3.0 7.0 2.0 5.0] [4.0 0.0 1.0 1.0] [1.0 6.0 3.0 0.0] [2.0 8.0 4.0 3.0]] 4)
	\end{lstlisting}
\end{center}



%\section{Матрица}
%
%\textbf{Матрицой}~\cite{matrix} называют таблицу чисел $a_{ik}$ вида
%\begin{equation}
%	\begin{pmatrix}
%		a_{11} & a_{12} & \ldots & a_{1n}\\
%		a_{21} & a_{22} & \ldots & a_{2n}\\
%		\vdots & \vdots & \ddots & \vdots\\
%		a_{m1} & a_{m2} & \ldots & a_{mn}
%	\end{pmatrix},
%\end{equation}
%
%состоящую из $m$ строк и $n$ столбцов. Числа $a_{ik}$ называются её \textit{элементами}.
%
%Пусть $A$ -- матрица, тогда $A_{i,j}$ -- элемент этой матрицы, который находится на \textit{i-ой} строке и \textit{j-ом} столбце.
%
%Можно выделить следующие операции над матрицами:
%\begin{enumerate}[label=\arabic*)]
%    \item сложение матриц одинакового размера;
%    \item вычитание матриц одинакового размера;
%    \item умножение матриц в случае, если количество столбцов первой матрицы равно количеству строк второй матрицы. В итоговой матрице количество строк будет, как у первой матрицы, а столбцов -- как у второй. \newline
%\end{enumerate}
%
%\textit{Замечание:} операция умножения матриц не коммутативна -- если \textit{A} и \textit{B} -- квадратные матрицы, а \textit{C} -- результат их перемножения, то произведение \textit{AB} и \textit{BA} дадут разный результат \textit{C}.
%\clearpage
%
%\section{Стандартный алгоритм}
%
%Пусть даны две матрицы
%
%\begin{equation}
%	A_{lm} = \begin{pmatrix}
%		a_{11} & a_{12} & \ldots & a_{1m}\\
%		a_{21} & a_{22} & \ldots & a_{2m}\\
%		\vdots & \vdots & \ddots & \vdots\\
%		a_{l1} & a_{l2} & \ldots & a_{lm}
%	\end{pmatrix},
%	\quad
%	B_{mn} = \begin{pmatrix}
%		b_{11} & b_{12} & \ldots & b_{1n}\\
%		b_{21} & b_{22} & \ldots & b_{2n}\\
%		\vdots & \vdots & \ddots & \vdots\\
%		b_{m1} & b_{m2} & \ldots & b_{mn}
%	\end{pmatrix},
%\end{equation}
%
%тогда матрица $C$
%\begin{equation}
%	C_{ln} = \begin{pmatrix}
%		c_{11} & c_{12} & \ldots & c_{1n}\\
%		c_{21} & c_{22} & \ldots & c_{2n}\\
%		\vdots & \vdots & \ddots & \vdots\\
%		c_{l1} & c_{l2} & \ldots & c_{ln}
%	\end{pmatrix},
%\end{equation}
%
%где
%\begin{equation}
%	\label{eq:M}
%	c_{ij} =
%	\sum_{r=1}^{m} a_{ir}b_{rj} \quad (i=\overline{1,l}; j=\overline{1,n})
%\end{equation}
%
%будет называться произведением матриц $A$ и $B$ \cite{matrix}.
%
%Стандартный алгоритм~\cite{vinograd-matrix} реализует данную формулу.
%
%
%\section{Алгоритм Винограда}
%
%\textbf{Алгоритм Винограда}~\cite{vinograd-matrix} -- алгоритм умножения квадратных матриц. Начальная версия имела асимптотическую сложность алгоритма примерно $O(n^{2,3755})$, где $n$ -- размер стороны матрицы, но после доработки он стал обладать лучшей асимптотикой среди всех алгоритмов умножения матриц.
%
%Рассмотрим два вектора $U = (u_1, u_2, u_3, u_4)$ и $W = (w_1, w_2, w_3, w_4)$.
%Их скалярное произведение равно: $U \cdot W = u_1w_1 + u_2w_2 + u_3w_3 + u_4w_4$, что эквивалентно (\ref{for:new}).
%\begin{equation}
%	\label{for:new}
%	V \cdot W = (u_1 + w_2)(u_2 + w_1) + (u_3 + w_4)(u_4 + w_3) - u_1u_2 - u_3u_4 - w_1w_2 - w_3w_4.
%\end{equation}
%
%За счёт предварительной обработки данных можно получить прирост производительности: несмотря на то, что  полученное выражение требует большего количества операций, чем стандартное умножение матриц, выражение в правой части равенства можно вычислить заранее и запомнить для каждой строки первой матрицы и каждого столбца второй матрицы. 
%Это позволит выполнить лишь два умножения и пять сложений, при учёте, что потом будет сложено только с двумя предварительно посчитанными суммами соседних элементов текущих строк и столбцов. 
%Операция сложения выполняется быстрее, поэтому на практике алгоритм должен работать быстрее обычного алгоритма перемножения матриц.
%
%Стоит упомянуть, что при нечётном значении размера матрицы нужно дополнительно добавить произведения крайних элементов соответствующих строк и столбцов.
%
%\section{Оптимизация алгоритма Винограда}
%
%При программной реализации рассмотренного выше алгоритма Винограда можно сделать следующие оптимизации:
%\begin{enumerate}[label=\arabic*)]
%	\item значение $\frac{N}{2}$, используемое как ограничения цикла подсчёта предварительных данных, можно кэшировать;
%	\item операцию умножения на 2 программно эффективнее реализовывать как побитовый сдвиг влево на 1;
%	\item операции сложения и вычитания с присваиванием следует реализовывать при помощи соответствующего оператора $+=$ или $-=$ (при наличии данных операторов в выбранном языке программирования).
% \end{enumerate}
%
%
%\section*{Вывод}
%
%В данном разделе были рассмотрены алгоритмы умножения матриц -- стандартного и Винограда, который имеет большую эффективность за счёт предварительных вычислений. 
%Также были рассмотрены оптимизации, которые можно учесть при программной реализации алгоритма Винограда.
%
%Алгоритмы будут получать на вход две матрицы, причём количество столбцов одной матрицы должно совпадать с количеством строк второй матрицы. 
%При вводе пустой матрицы будет выведено сообщение об ошибке. 
%Требуется реализовать программное обеспечение, которое даёт возможность выбрать один из алгоритмов или все сразу, ввести две матрицы и вывести результат их перемножения.
%Также необходимо провести замеры времени работы реализаций алгоритмов для чётных и нечётных размеров матриц и сравнить результаты, используя графическое представление.
